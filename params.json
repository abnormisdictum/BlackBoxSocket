{"name":"BlackBoxSocket","tagline":"My twist to a Java based secure layer for socket communication.","body":"#BlackBoxSocket\r\n\r\n###UPDATE:\r\n<p>Moving factor has been added to Time based OTP in order to make sure that the SecretKeys for each individual message is changed when created under a 60 seconds. This MovingFactor is incremented by a MovingFactor_increment parameter each time a new message is sent or recieved. Both these parameters are agreed upon when BlackBoxSocket is initialized.</p>\r\n\r\n<p>My twist to a Java based secure layer for socket communication.\r\nEssentially what it does is as follows:</p>\r\n1. When a BlackBox Client or Server is connects client send over the client's public key.\r\n2. Then the server send it's public key to client\r\n3. Then, depending on whether the BlackBoxSocket is client controlled or server controlled, the client or server respectively generates two AES Keys.\r\n    a. A Aes SecretKey that encrypts the Message JSON string, known as OuterLayerSecretKey\r\n    b. A Aes SecretKey which is used as the key for a Time-based OTP algotrithm to generate further Aes keys for each message.\r\n4. Once that is done, each message interaction can be done using the Message class.\r\n5. The message class:\r\n    1. Accepts the String message.\r\n    2. Creates and stores a signature of the message using Rsa and the Client/Server 's privateKey.\r\n    3. Generates a Salt that is used to create the Message's AES SecretKey.\r\n    4. Generates the AES Key using MessageSecretKey and Salt and then encrypts and stores the message in the Message class.\r\n    5. The Message Class toString() function returns a JSON String containing all the message data parameters except time.\r\n6. When the remote device recieves the Encrypted String\r\n    1. It decrypts it to get the JSON String using OuterLayerSecretKey.\r\n    2. Then creates a Message object by passing the JSON String along with the MessageSecretKey and the remote devices public key, and then stores the OTP timestamp.\r\n    3. It outputs the message in the object using the getMessage() function which\r\n        1. Generates the messages SecretKey using MessageSecretKey and the timestamp.\r\n        2. Authenticates the message using remote devices public key, if it failes to authenticate, it destroys the data.\r\n        3. Decrypts the message using the newly generated message Key and outputs the message.\r\n    \r\nThe program thus relies on the devices to generate each individual message key. Thereby improving security, at least in my head.","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}